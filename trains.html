<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Trains for Joyce</title>
    <style>
		body {width:980px}
    	* { padding: 0; margin: 0; -webkit-tap-highlight-color:rgba(0,0,0,0); }
    	canvas { position:absolute; top:40px; }
	#bgCanvas { z-index: 1; }
	#difficultSecondCanvas {z-index: 2;}
	#drawCanvas { z-index: 3; }
	#uiCanvas { z-index: 4; }

		#topbar {
			background-color: #22721c;
			color: #ffffff;
			height: 40px;
		}
		.stat {
			width: 120px;
			margin: 6px;
		}
		.topbarcontents {
			padding: 5px;
			display: flex;
			margin-left: 600px;
		}
    </style>
</head>
<body>

	<div id="topbar">
		<div class="topbarcontents">
		<div class="stat">
				CORRECT:
				<span id="correct">0</span>
		</div>
		<div class="stat">
				INCORRECT:
				<span id="incorrect">0</span>
		</div>
		</div>
	</div>

<canvas id="bgCanvas" width="980" height="1400"></canvas>
<canvas id="difficultSecondCanvas" width="980" height="1400"></canvas>
<canvas id="drawCanvas" width="980" height="1400"></canvas>
<canvas id="uiCanvas" width="980" height="1400"></canvas>

<script>
	/*
	VARIABLES
	*/
	var backgroundColor = "#004d00";
	var nodeColor = "#00b300";
	var displayTypes = [
		{
			colors: ["#b5050e"]
		},
		{
			colors: ["#1605b5"]
		},
		{
			colors: ["#1605b5"]
		},
		{
			colors: ["#1605b5"]
		},
		{
			colors: ["#1605b5"]
		},
		{
			colors: ["#1605b5"]
		},
		{
			colors: ["#1605b5"]
		},
		{
			colors: ["#1605b5"]
		},
		{
			colors: ["#1605b5"]
		},
		{
			colors: ["#1605b5"]
		},
		{
			colors: ["#1605b5"]
		},
		{
			colors: ["#1605b5"]
		},
		{
			colors: ["#1605b5"]
		},
		{
			colors: ["#1605b5"]
		}
	]

	var unitlength = 170;
	var pixwidth = 980;
	var pixheight = 1400;
	var tilewidth = 5;
	var tileheight = 8;
	var vpadding = (pixheight - (unitlength * tileheight))/2;
	var hpadding = (pixwidth - (unitlength * tilewidth))/2;

	var movementPerFrame = 0.019;

	var tiles = createArray(tileheight, tilewidth);
	tiles[1][1] = {type:"source", out:"south"};
	tiles[2][1] = {type:"track", in:"north", out:"south"};
	tiles[3][1] = {type:"node", in:"north", out:["south", "east"], current:0};
	tiles[4][1] = {type:"track", in:"north", out:"south"};
	tiles[5][1] = {type:"sink", in:"north", accepts:"a"};
	tiles[3][2] = {type:"track", in:"west", out:"east"};
	tiles[3][3] = {type:"sink", in:"west", accepts:"b"};

	/*
	Extension methods
	*/
	function createArray(rows, cols) {
		var arr = new Array(rows);
		for (var i=0;i<rows;i++) {
			arr[i] = new Array(cols);
		}
		return arr;
	}

	function select(arr, f) {
		var results = [];
		arr.forEach(function(element) {
			results.push(f(element));
		});
		return results;
	}

	function selectMany(arr, f) {
		var results = [];
		arr.forEach(function(row) {
			row.forEach(function(tile) {
				var x = f(tile);
				if (x != undefined) {
					results.push(x);
				}
			});
		});
		return results;
	}

	function randomInteger(max) {
		return Math.floor((Math.random() * max));
	}

	function randomlyAssignKeysToValues(keys, values) {
		var result = {};
		var unusedValues = values.slice(0);
		keys.forEach(function(key) {
			var index = randomInteger(unusedValues.length);
			result[key] = unusedValues[index];
			unusedValues.splice(index, 1);
		});
		return result;
	}	

	function linearCombine(from, to, pc) {
		var x = (from.x * (1-pc)) + (to.x * pc);
		var y = (from.y * (1-pc)) + (to.y * pc);
		return {x: x, y: y};
	}

	function first(f, arr) {
		for (var y = 0; y< arr.length; y++) {
			var subarr = arr[y];
			for (var x = 0; x < subarr.length; x++) {
				if (f(subarr[x])) {
					return {x: x, y: y};
				}
			}
		}
	}

	/*
	Drawing-specific functions
	*/

	function tileToPix(tiley, pcy, tilex, pcx) {
		var x = hpadding + (unitlength*tilex) + (unitlength * pcx);
		var y = vpadding + (unitlength*tiley) + (unitlength * pcy);
		return {x: x, y: y};
	}

	function pixToTile(x, y) {
		var tilex = Math.floor((x - hpadding)/unitlength);
		var tiley = Math.floor((y - vpadding)/unitlength);
		return {x: tilex, y: tiley};
	}	

	function moveTo(context,pos) {
		context.moveTo(pos.x, pos.y);
	}

	function lineTo(context,pos) {
		context.lineTo(pos.x, pos.y);
	}

	function drawLine(context, pos1, pos2, thickness, color) {		
		context.beginPath();
		context.lineWidth = thickness;
		moveTo(context,pos1);
		lineTo(context,pos2);
		context.strokeStyle = color;
		context.stroke();
		context.closePath();
	}

	function drawCircle(context, pos, radius, colour) {
		context.beginPath();
		context.arc(pos.x, pos.y, radius * unitlength, 0, Math.PI*2, false);
		context.fillStyle = colour;
		context.fill();
		context.closePath();
	}

	function drawRect(context, pos1, pos2, colour) {
		context.beginPath();
		context.rect(pos1.x, pos1.y, pos2.x - pos1.x, pos2.y - pos1.y);
		context.fillStyle = colour;
		context.fill();
		context.closePath();
	}
	
	/*
	DIRECTION
	*/

	function oppositeDirection(dir) {		
		switch(dir) {
			case "north":
				return "south";
			case "east":
				return "west";
			case "south":
				return "north";
			case "west":
				return "east";
		}
	}

	function offsetFromDirection(dir) {
		switch(dir) {
			case "north":
				return {x:0.5,y:0};
			case "east":
				return {x:1,y:0.5};
			case "south":
				return {x:0.5,y:1};
			case "west":
				return {x:0,y:0.5};
		}
	}

	function nextFromDirection(tilepos, outdir) {
		switch(outdir) {
			case "north":
				var next = {x: tilepos.x, y: tilepos.y-1};
				break;
			case "west":
				var next = {x: tilepos.x-1, y: tilepos.y};
				break;
			case "east":
				var next = {x: tilepos.x+1, y: tilepos.y};
				break;
			case "south":
				var next = {x: tilepos.x, y: tilepos.y+1};
				break;
		}
		return next;
	}

	/*
	TILE DRAWING
	*/

	function drawTrackLine(context, pos1, pos2) {
		drawLine(context, pos1, pos2, 7, "black");
		drawLine(context, pos1, pos2, 3, "white");
	}

	function drawTrack(x, y, indir, out, context) {
		var inoffset = offsetFromDirection(indir);
		var outoffset = offsetFromDirection(out);
		var pos1 = tileToPix(y,inoffset.y,x,inoffset.x);
		var pos2 = tileToPix(y,outoffset.y,x,outoffset.x);
		drawTrackLine(context, pos1, pos2);
	}

	function drawNodeTrack(x, y, obj) {
		var topleft = tileToPix(y,0,x,0);
		contexts[movingBgCanvas].clearRect(topleft.x + 1, topleft.y + 1, unitlength - 2, unitlength - 2);
		var indir = obj.in;
		var out = obj.out[obj.current];
		drawTrack(x, y, indir, out, contexts[movingBgCanvas]);
	}

	/*
	SETUP
	*/

	var acceptedTypes = selectMany(tiles, function(tile) {
		if (tile.type == "sink") {
			return tile.accepts;
		}
		return undefined;
	});

	var typeDict = randomlyAssignKeysToValues(acceptedTypes, displayTypes);

	var canvases = select(["bgCanvas", "difficultSecondCanvas", "drawCanvas", "uiCanvas"], function(c) {
		return document.getElementById(c);
	});
	var contexts = select(canvases, function(c) {
		return c.getContext("2d");
	});
	var backgroundCanvas = 0;
	var movingBgCanvas = 1;
	var trainCanvas = 2;
	var uiCanvas = 3;

	function drawBg() {
		drawRect(contexts[backgroundCanvas],{x:0,y:0},{x:pixwidth, y:pixheight},backgroundColor);
		for (var y=0; y<tileheight; y++) {
			for (var x=0; x<tilewidth; x++) {
				var obj = tiles[y][x];
				if (obj != undefined) {
					switch (obj.type) {
	case "source":
		drawCircle(contexts[backgroundCanvas], tileToPix(y,0.5,x,0.5),0.3,"gray");
		var offset = offsetFromDirection(obj.out);
		drawTrackLine(contexts[backgroundCanvas], tileToPix(y,0.5,x,0.5), tileToPix(y,offset.y,x,offset.x));
		break;
	case "track":
		drawTrack(x, y, obj.in, obj.out, contexts[backgroundCanvas]);
		break;
	case "node":
		obj.out.forEach(function(o) {
			var offset = offsetFromDirection(o);
			drawTrackLine(contexts[backgroundCanvas], tileToPix(y,0.5,x,0.5), tileToPix(y, offset.y, x, offset.x));
		});
		drawCircle(contexts[backgroundCanvas], tileToPix(y,0.5,x,0.5), 0.39, nodeColor);
		drawNodeTrack(x, y, obj);
		break;
	case "sink":
		drawCircle(contexts[backgroundCanvas], tileToPix(y,0.5,x,0.5), 0.4, typeDict[obj.accepts].colors[0]);
		var offset = offsetFromDirection(obj.in);
		drawTrackLine(contexts[backgroundCanvas], tileToPix(y,0.5,x,0.5), tileToPix(y,offset.y,x,offset.x));
		break;
					}
				}
			}
		}
	}

	drawBg();

	/*
	Runtime variables
	*/
	var trains = [];
	var correct = 0;
	var incorrect = 0;
	var correctspan = document.getElementById("correct");
	var incorrectspan = document.getElementById("incorrect");

	function getNewTrainPosition(tilepos) {
		var tile = tiles[tilepos.y][tilepos.x];
		var from = offsetFromDirection(tile.in);
		if (tile.type == "sink") {
			var to = offsetFromDirection(oppositeDirection(tile.in));
			var next = {};
		}
		else {
			if (tile.type == "node") {
				var outdir = tile.out[tile.current];
			}
			else {
				var outdir = tile.out;
			}
			var to = offsetFromDirection(outdir);
			next = nextFromDirection(tilepos, outdir);
		}
		return { fromPos: from, toPos: to, thisTile: tilepos, nextTile: next, pc: 0 };
	}


	function doFrame() {
		var trainsToRemove = [];
		trains.forEach(function(train) {
			train.position.pc += movementPerFrame;
			var tile = tiles[train.position.thisTile.y][train.position.thisTile.x];
			if (train.position.pc >= 1) {
				train.position = getNewTrainPosition(train.position.nextTile);
			}
			else if (tile.type == "sink" && train.position.pc >= 0.5) {
				if (tile.accepts == train.type) {
					correct++;
				} else {
					incorrect++;
				}
				correctspan.innerHTML = correct;
				incorrectspan.innerHTML = incorrect;
				trainsToRemove.push(trains.indexOf(train));
			}
		});
		trainsToRemove.forEach(function(index) {
			trains.splice(index, 1);
		});
		contexts[trainCanvas].clearRect(0, 0, canvases[trainCanvas].width, canvases[trainCanvas].height);
		trains.forEach(function(train) {
			var tilepoint = linearCombine(train.position.fromPos, train.position.toPos, train.position.pc);
			var pxpoint = tileToPix(train.position.thisTile.y, tilepoint.y, train.position.thisTile.x,tilepoint.x);
			drawCircle(contexts[trainCanvas], pxpoint, 0.2, typeDict[train.type].colors[0])
		});
	}

	setInterval(doFrame, 33);

	function makeTrain(source, sourceTile) {
		var type = acceptedTypes[randomInteger(acceptedTypes.length)];
		trains.push({
			position: { 
					fromPos: offsetFromDirection(oppositeDirection(sourceTile.out)), 
					toPos: offsetFromDirection(sourceTile.out), 
					thisTile: source, 
					nextTile: nextFromDirection(source, sourceTile.out), 
					pc: 0.5 },
			type: type
		});
	}

	var firstsource = first(function (tile) {
		return (tile != undefined && tile.type == "source");
	}, tiles);
	var firstsourceTile = tiles[firstsource.y][firstsource.x];

	function trainGenerate() {
		makeTrain(firstsource, firstsourceTile);
	}

	setInterval(trainGenerate, 2500);

	var uicanvas = document.getElementById("uiCanvas");
	var elemLeft = uicanvas.offsetLeft;
	var elemTop = uicanvas.offsetTop;
	function onClick(event) {
		var tilepos = pixToTile(event.pageX - elemLeft, event.pageY - elemTop)
		console.log(tilepos);
		if (tilepos.x >= 0 && tilepos.x < tilewidth && tilepos.y >= 0 && tilepos.y < tileheight) {
			var obj = tiles[tilepos.y][tilepos.x];
			if (obj != undefined && obj.type=="node") {
				obj.current = 1 - obj.current;
				drawNodeTrack(tilepos.x, tilepos.y, obj);
			}
		}
	}
	uicanvas.addEventListener('click', onClick, false);

</script>

</body>
</html>